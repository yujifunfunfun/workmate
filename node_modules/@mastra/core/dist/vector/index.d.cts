import { M as MastraBase } from '../base-BihKcqDY.cjs';
import { VectorFilter } from './filter/index.cjs';
import '@opentelemetry/api';
import '../index-CquI0inB.cjs';
import 'stream';
import 'pino';
import '@opentelemetry/sdk-trace-base';

interface QueryResult {
    id: string;
    score: number;
    metadata?: Record<string, any>;
    vector?: number[];
    /**
     * The document content, if available.
     * Note: Currently only supported by Chroma vector store.
     * For other vector stores, documents should be stored in metadata.
     */
    document?: string;
}
interface IndexStats {
    dimension: number;
    count: number;
    metric?: 'cosine' | 'euclidean' | 'dotproduct';
}
interface UpsertVectorParams {
    indexName: string;
    vectors: number[][];
    metadata?: Record<string, any>[];
    ids?: string[];
}
type UpsertVectorArgs = [string, number[][], Record<string, any>[], string[]?];
interface CreateIndexParams {
    indexName: string;
    dimension: number;
    metric?: 'cosine' | 'euclidean' | 'dotproduct';
}
type CreateIndexArgs = [string, number, 'cosine' | 'euclidean' | 'dotproduct'];
interface QueryVectorParams {
    indexName: string;
    queryVector: number[];
    topK?: number;
    filter?: VectorFilter;
    includeVector?: boolean;
}
type QueryVectorArgs = [string, number[], number, VectorFilter?, boolean?];
type ParamsToArgs<T> = [T] | (T extends QueryVectorParams ? QueryVectorArgs : never) | (T extends UpsertVectorParams ? UpsertVectorArgs : never) | (T extends CreateIndexParams ? CreateIndexArgs : never);

declare abstract class MastraVector extends MastraBase {
    constructor();
    private readonly baseKeys;
    protected normalizeArgs<T, E extends any[] = never>(method: string, [first, ...rest]: ParamsToArgs<T> | E, extendedKeys?: string[]): T;
    abstract query<E extends QueryVectorArgs = QueryVectorArgs>(...args: ParamsToArgs<QueryVectorParams> | E): Promise<QueryResult[]>;
    abstract upsert<E extends UpsertVectorArgs = UpsertVectorArgs>(...args: ParamsToArgs<UpsertVectorParams> | E): Promise<string[]>;
    abstract createIndex<E extends CreateIndexArgs = CreateIndexArgs>(...args: ParamsToArgs<CreateIndexParams> | E): Promise<void>;
    abstract listIndexes(): Promise<string[]>;
    abstract describeIndex(indexName: string): Promise<IndexStats>;
    abstract deleteIndex(indexName: string): Promise<void>;
    updateIndexById(_indexName: string, _id: string, _update: {
        vector?: number[];
        metadata?: Record<string, any>;
    }): Promise<void>;
    deleteIndexById(_indexName: string, _id: string): Promise<void>;
}

export { type CreateIndexArgs, type CreateIndexParams, type IndexStats, MastraVector, type ParamsToArgs, type QueryResult, type QueryVectorArgs, type QueryVectorParams, type UpsertVectorArgs, type UpsertVectorParams };
